<!-- 
 Generated by ChatGPT
 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Feed Binarization with Color Picker and Threshold</title>
</head>
<body>
    <h1>Camera Feed Binarization with Color Picker and Threshold</h1>
    A small chatGPT-created proof of concept for a joint project between classes.
    Directions:
    <ol>
        <li>Find an object of a solid color.</li>
        <li>Choose the color that looks most similar to it from the color picker.</li>
        <li>Hold the object up to the camera.</li>
        <li>Adjust the threshold so only your object shows up in white in the black rectangle on the right.</li>
        <li>See how the red dot tracks the centroid of your image.</li>
    </ol>
    
    <label for="colorPicker">Choose a target color:</label>
    <input type="color" id="colorPicker" value="#ff0000"><br><br>

    <label for="thresholdSlider">Adjust the threshold:</label>
    <input type="range" id="thresholdSlider" min="0" max="255" value="100">
    <span id="thresholdValue">100</span><br><br>

    <video id="video" width="320" height="240" autoplay></video>
    <canvas id="canvas" width="320" height="240"></canvas>
    <p id="centroidOutput">Centroid: (x, y)</p>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const centroidOutput = document.getElementById('centroidOutput');
        const colorPicker = document.getElementById('colorPicker');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValue = document.getElementById('thresholdValue');

        // Default target color and threshold
        let targetColor = [255, 0, 0]; // Initial color: Red
        let threshold = 100; // Initial threshold value

        // Get access to the user's camera
        navigator.mediaDevices.getUserMedia({ video: true })
            .then((stream) => {
                video.srcObject = stream;
            })
            .catch((err) => {
                console.error("Error accessing camera: ", err);
            });

        // Function to compute Euclidean distance between two RGB colors
        function colorDistance(c1, c2) {
            return Math.sqrt(
                (c1[0] - c2[0]) ** 2 +
                (c1[1] - c2[1]) ** 2 +
                (c1[2] - c2[2]) ** 2
            );
        }

        // Convert hex color (#rrggbb) to [r, g, b]
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return [r, g, b];
        }

        // Function to binarize the image based on distance to target color
        function captureAndBinarizeFrame() {
            const width = canvas.width;
            const height = canvas.height;

            // Draw the current video frame onto the canvas
            context.drawImage(video, 0, 0, width, height);

            // Get pixel data from the canvas
            const imageData = context.getImageData(0, 0, width, height);
            const data = imageData.data;

            // Create a 2D binary array to track white (1) and black (0) pixels
            const binaryArray = Array.from({ length: height }, () => Array(width).fill(0));

            // Binarize the image based on the Euclidean distance to the target color
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];

                    // Calculate Euclidean distance to the target color
                    const distance = colorDistance([r, g, b], targetColor);

                    // If the distance is below the threshold, mark the pixel as white, otherwise black
                    const binaryValue = distance < threshold ? 255 : 0;
                    binaryArray[y][x] = binaryValue === 255 ? 1 : 0;

                    // Update the canvas data: set to either white or black
                    data[index] = binaryValue;
                    data[index + 1] = binaryValue;
                    data[index + 2] = binaryValue;
                    // Alpha remains unchanged
                }
            }

            // Find the largest connected component (island) of white pixels
            const largestComponent = findLargestConnectedComponent(binaryArray);

            // Calculate the centroid of the largest component
            const centroid = calculateCentroid(largestComponent);
            centroidOutput.textContent = `Centroid: (${centroid.x.toFixed(2)}, ${centroid.y.toFixed(2)})`;

            // Put the binarized image back onto the canvas
            context.putImageData(imageData, 0, 0);

            // Draw the centroid as a red dot on the canvas
            if (centroid.x && centroid.y) {
                drawCentroid(centroid.x, centroid.y);
            }
        }

        // Flood fill algorithm to find connected components
        function findLargestConnectedComponent(binaryArray) {
            const height = binaryArray.length;
            const width = binaryArray[0].length;
            const visited = Array.from({ length: height }, () => Array(width).fill(false));
            let largestComponent = [];
            
            function floodFill(x, y) {
                const stack = [[x, y]];
                const component = [];

                while (stack.length > 0) {
                    const [cx, cy] = stack.pop();

                    if (cx < 0 || cy < 0 || cx >= width || cy >= height) continue;
                    if (visited[cy][cx] || binaryArray[cy][cx] === 0) continue;

                    visited[cy][cx] = true;
                    component.push([cx, cy]);

                    stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                }

                return component;
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (binaryArray[y][x] === 1 && !visited[y][x]) {
                        const component = floodFill(x, y);
                        if (component.length > largestComponent.length) {
                            largestComponent = component;
                        }
                    }
                }
            }

            return largestComponent;
        }

        // Function to calculate the centroid of a component
        function calculateCentroid(component) {
            if (component.length === 0) return { x: 0, y: 0 };

            let sumX = 0, sumY = 0;
            component.forEach(([x, y]) => {
                sumX += x;
                sumY += y;
            });

            const centroidX = sumX / component.length;
            const centroidY = sumY / component.length;

            return { x: centroidX, y: centroidY };
        }

        // Function to draw the centroid on the canvas as a red dot
        function drawCentroid(x, y) {
            context.beginPath();
            context.arc(x, y, 5, 0, 2 * Math.PI); // Draw a circle at the centroid (radius 5)
            context.fillStyle = 'red'; // Set color to red
            context.fill();
        }

        // Update the threshold value when the slider is adjusted
        thresholdSlider.addEventListener('input', (event) => {
            threshold = event.target.value;
            thresholdValue.textContent = threshold;
        });

        // Update the target color when the color picker is changed
        colorPicker.addEventListener('input', (event) => {
            targetColor = hexToRgb(event.target.value);
        });

        // Capture and binarize the frame every 100 milliseconds (10 FPS)
        setInterval(captureAndBinarizeFrame, 100);
    </script>
</body>
</html>
